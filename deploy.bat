@echo off
setlocal enabledelayedexpansion

REM -------------------------
REM Prevent labels from running at load
REM -------------------------
goto :main

REM -------------------------
REM Load .env.deploy into batch vars (simple parser)
REM -------------------------
:load_env
set "DB_NAME="
set "DB_USER="
set "DB_PASS="
set "DB_HOST="
set "DB_PORT="
set "MARKETSTACK_API_KEYS="
set "GIT_REPO="
set "GIT_REF="
if exist "%ENV_FILE%" (
  for /f "usebackq tokens=1* delims==" %%A in ("%ENV_FILE%") do (
    set "K=%%A"
    set "V=%%B"
    rem trim leading spaces from K and V
    for /f "tokens=* delims= " %%K2 in ("!K!") do set "K=%%K2"
    for /f "tokens=* delims= " %%V2 in ("!V!") do set "V=%%V2"
    rem skip comments and empty keys
    if not "!K!"=="" (
      if NOT "!K:~0,1!"=="#" (
        rem remove surrounding quotes on value
        if "!V:~0,1!"=="\"" set "V=!V:~1!"
        if "!V:~-1!"=="\"" set "V=!V:~0,-1!"
        set "!K!=!V!"
      )
    )
  )
)
exit /b 0

REM -------------------------
REM Prompt helper: call :ask VAR "Prompt" "default"
REM -------------------------
:ask
set "_ASK_VAR=%~1"
set "_ASK_MSG=%~2"
set "_ASK_DEF=%~3"
set "_TMPVAL="
if defined _ASK_DEF (
  set /p _TMPVAL=%_ASK_MSG% [%_ASK_DEF%]: 
  if not "%_TMPVAL%"=="" (
    set "%_ASK_VAR%=%_TMPVAL%"
  ) else (
    set "%_ASK_VAR%=%_ASK_DEF%"
  )
) else (
  set /p _TMPVAL=%_ASK_MSG%: 
  set "%_ASK_VAR%=%_TMPVAL%"
)
exit /b 0

REM -------------------------
REM Write .env.deploy (asks for values)
REM -------------------------
:write_env
echo.
echo Configuring %ENV_FILE%...
if exist "%ENV_FILE%" (
  set /p OVERWRITE=File %ENV_FILE% exists. Overwrite? [y/N]: 
  if /I not "%OVERWRITE%"=="y" (
    echo Keeping existing %ENV_FILE%.
    exit /b 0
  )
)

REM defaults
set "DB_NAME=stocks_db"
set "DB_USER=stock_user"
set "DB_PASS=stock_pass"
set "DB_HOST=postgres"
set "DB_PORT=5432"
set "MARKETSTACK_API_KEYS="
set "GIT_REPO=https://github.com/IAteNoodles/stock_docker.git"
set "GIT_REF=master"

call :ask DB_NAME "Postgres DB name" "%DB_NAME%"
call :ask DB_USER "Postgres DB user" "%DB_USER%"
call :ask DB_PASS "Postgres DB password" "%DB_PASS%"
call :ask DB_HOST "Postgres host (container name / host)" "%DB_HOST%"
call :ask DB_PORT "Postgres port" "%DB_PORT%"
call :ask MARKETSTACK_API_KEYS "Marketstack API keys (comma-separated)" "%MARKETSTACK_API_KEYS%"
call :ask GIT_REPO "App Git repo (URL, used by Dockerfile.git)" "%GIT_REPO%"
call :ask GIT_REF "App Git ref (branch/tag/commit)" "%GIT_REF%"

(
  echo # Generated by deploy.bat on %DATE% %TIME%
  echo DB_NAME=!DB_NAME!
  echo DB_USER=!DB_USER!
  echo DB_PASS=!DB_PASS!
  echo DB_HOST=!DB_HOST!
  echo DB_PORT=!DB_PORT!
  echo.
  echo # Comma-separated API keys for Marketstack
  echo MARKETSTACK_API_KEYS=!MARKETSTACK_API_KEYS!
  echo.
  echo # Repo and ref for the application cloned during image build
  echo GIT_REPO=!GIT_REPO!
  echo GIT_REF=!GIT_REF!
) > "%ENV_FILE%"

echo Wrote %ENV_FILE%
exit /b 0

REM -------------------------
REM Wait for Postgres inside container to accept connections
REM -------------------------
:db_wait_ready
echo [deploy] waiting for Postgres to accept connections...
%COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" exec -T postgres sh -lc "set -e; U=\"${POSTGRES_USER:-postgres}\"; until pg_isready -h 127.0.0.1 -p 5432 -q -U \"$U\" -d postgres; do sleep 1; done" >nul 2>&1 || (
  echo [deploy] warning: postgres wait failed or timed out (continuing)
)
exit /b 0

REM -------------------------
REM Create DB if missing
REM -------------------------
:db_create_if_missing
call :load_env
if not defined DB_NAME (
  echo [deploy] Warning: DB_NAME not set in %ENV_FILE%; skipping DB creation
  exit /b 0
)
echo [deploy] checking for database %DB_NAME%...
%COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" exec -T postgres sh -lc "set -e; U=\"${POSTGRES_USER:-postgres}\"; EXISTS=\$(psql -U \"$U\" -d postgres -Atqc \"SELECT 1 FROM pg_database WHERE datname='!DB_NAME!';\"); if [ \"\$EXISTS\" != \"1\" ]; then echo [deploy] creating database !DB_NAME!; psql -U \"$U\" -d postgres -v ON_ERROR_STOP=1 -c \"CREATE DATABASE \\\"!DB_NAME!\\\";\"; else echo [deploy] database !DB_NAME! already exists; fi" || echo [deploy] create-if-missing step skipped/failed
exit /b 0

REM -------------------------
REM Apply minimal schema if DB exists
REM -------------------------
:db_apply_schema
call :load_env
if not defined DB_NAME (
  echo [deploy] DB_NAME not set; skipping schema apply
  exit /b 0
)
echo [deploy] applying minimal schema to %DB_NAME%...
%COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" exec -T postgres sh -lc "set -e; U=\"${POSTGRES_USER:-postgres}\"; psql -U \"$U\" -d \"!DB_NAME!\" -v ON_ERROR_STOP=1 -c \"CREATE TABLE IF NOT EXISTS history (symbol TEXT PRIMARY KEY, latest_data_date DATE);\"; psql -U \"$U\" -d \"!DB_NAME!\" -v ON_ERROR_STOP=1 -c \"CREATE TABLE IF NOT EXISTS latest (symbol TEXT PRIMARY KEY, data JSONB NOT NULL, last_updated TIMESTAMPTZ NOT NULL DEFAULT NOW());\"" || echo [deploy] schema step skipped/failed
exit /b 0

REM -------------------------
REM Ensure DB exists and schema applied
REM -------------------------
:ensure_db_exists
call :db_wait_ready
call :db_create_if_missing
call :db_apply_schema
exit /b 0

REM -------------------------
REM Up command (build + up)
REM -------------------------
:up
if not exist "%COMPOSE_FILE%" (
  echo Error: compose file not found: %COMPOSE_FILE%
  pause
  exit /b 1
)
if not exist "%ENV_FILE%" (
  echo %ENV_FILE% not found. Running init...
  call :write_env
)
set "NO_CACHE=%~1"
echo [deploy] bringing up stack...
if /I "%NO_CACHE%"=="--no-cache" (
  %COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" build --no-cache || (echo Build failed & pause & exit /b 1)
  %COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" up -d || (echo Up failed & pause & exit /b 1)
) else (
  %COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" up -d --build || (echo Up failed & pause & exit /b 1)
)

rem after containers are up, ensure DB exists and schema
call :ensure_db_exists

echo Services started. Dagster UI: http://localhost:33000  API: http://localhost:8000  Postgres: localhost:65432
pause
exit /b 0

REM -------------------------
REM Down
REM -------------------------
:down
%COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" down
pause
exit /b 0

REM -------------------------
REM Restart
REM -------------------------
:restart
set "NO_CACHE=%~1"
%COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" down
if /I "%NO_CACHE%"=="--no-cache" (
  %COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" build --no-cache || (echo Build failed & pause & exit /b 1)
  %COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" up -d || (echo Up failed & pause & exit /b 1)
) else (
  %COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" up -d --build || (echo Up failed & pause & exit /b 1)
)
call :ensure_db_exists
pause
exit /b 0

REM -------------------------
REM Logs
REM -------------------------
:logs
set "SVC=%~1"
if defined SVC (
  %COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" logs -f --tail=200 "%SVC%"
) else (
  %COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" logs -f --tail=200
)
pause
exit /b 0

REM -------------------------
REM Status
REM -------------------------
:status
%COMPOSE_CMD% -f "%COMPOSE_FILE%" --env-file "%ENV_FILE%" ps
pause
exit /b 0

REM -------------------------
REM Init wrapper (alias)
REM -------------------------
:init
call :write_env
exit /b 0

REM -------------------------
REM Main
REM -------------------------
:main
REM Resolve absolute paths
set "SCRIPT_DIR=%~dp0"
for %%I in ("%SCRIPT_DIR%") do set "SCRIPT_DIR=%%~fI"
set "COMPOSE_FILE=%SCRIPT_DIR%docker-compose.deploy.yml"
set "ENV_FILE=%SCRIPT_DIR%.env.deploy"

REM Warn if there's a plain .env file (we intentionally use .env.deploy)
if exist "%SCRIPT_DIR%.env" (
  echo Warning: found .env in repo root. This script will use .env.deploy instead.
)

REM Detect docker compose command (supports both variants)
set "COMPOSE_CMD="
docker compose version >nul 2>&1 && set "COMPOSE_CMD=docker compose"
if not defined COMPOSE_CMD (
  docker-compose version >nul 2>&1 && set "COMPOSE_CMD=docker-compose"
)
if not defined COMPOSE_CMD (
  echo Error: docker compose not found. Install Docker Desktop or docker-compose.
  pause
  exit /b 1
)

REM If direct command passed, run it and exit
if /I "%~1"=="up" (
  call :up %~2
  exit /b 0
)
if /I "%~1"=="down" (
  call :down
  exit /b 0
)
if /I "%~1"=="restart" (
  call :restart %~2
  exit /b 0
)
if /I "%~1"=="logs" (
  call :logs %~2
  exit /b 0
)
if /I "%~1"=="status" (
  call :status
  exit /b 0
)
if /I "%~1"=="init" (
  call :init
  exit /b 0
)

REM No args -> interactive menu
:menu_top
cls
echo ==============================
echo   Docker Deploy Wizard
echo ==============================
echo 1^) Init (.env.deploy)
echo 2^) Up
echo 3^) Up (no-cache)
echo 4^) Down
echo 5^) Logs
echo 6^) Status
echo 7^) Restart
echo 8^) Restart (no-cache)
echo 0^) Exit
echo.

set /p CHOICE=Select option: 
if "%CHOICE%"=="1" (
  call :write_env
  goto :menu_top
)
if "%CHOICE%"=="2" (
  call :up
  goto :menu_top
)
if "%CHOICE%"=="3" (
  call :up --no-cache
  goto :menu_top
)
if "%CHOICE%"=="4" (
  call :down
  goto :menu_top
)
if "%CHOICE%"=="5" (
  set /p SVC=Service (blank=all): 
  call :logs "%SVC%"
  goto :menu_top
)
if "%CHOICE%"=="6" (
  call :status
  goto :menu_top
)
if "%CHOICE%"=="7" (
  call :restart
  goto :menu_top
)
if "%CHOICE%"=="8" (
  call :restart --no-cache
  goto :menu_top
)
if "%CHOICE%"=="0" (
  echo Exiting.
  exit /b 0
)

echo Invalid choice. Try again.
goto :menu_top
