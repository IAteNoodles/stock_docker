#!/usr/bin/env bash
set -euo pipefail

# Simple manager to clone, configure, and run the deploy stack.
# Usage:
#   ./deploy.sh                 # interactive wizard
#   ./deploy.sh up              # build and start services
#   ./deploy.sh down            # stop services
#   ./deploy.sh restart         # restart services
#   ./deploy.sh logs [svc]      # tail logs (optionally service)
#   ./deploy.sh ps              # show status
#   ./deploy.sh init            # prompt and (re)write .env.deploy
#   ./deploy.sh clone <url> [dir] [ref]   # clone a repo (default ref=main)
#
# Notes:
# - Expects docker-compose.deploy.yml in the working directory.
# - Writes .env.deploy with DB and provider settings, plus GIT_REPO/GIT_REF for build.
# - Safe to run from fish: this script uses its own bash shebang.

COMPOSE_FILE="docker-compose.deploy.yml"
ENV_FILE=".env.deploy"

require_compose() {
  if ! command -v docker &>/dev/null; then
    echo "Error: docker not found in PATH" >&2
    exit 1
  fi
  if ! docker compose version >/dev/null 2>&1; then
    echo "Error: docker compose plugin not available (need Docker Compose v2)" >&2
    exit 1
  fi
}

ensure_compose_file() {
  if [[ ! -f "$COMPOSE_FILE" ]]; then
    echo "Error: $COMPOSE_FILE not found in $(pwd)." >&2
    echo "Tip: run './deploy.sh clone <repo-url> [dir] [ref]' first, or cd into the repo root." >&2
    exit 1
  fi
}

prompt_var() {
  local var_name="$1"; shift
  local prompt="$1"; shift
  local default_val="${1-}"
  local val
  if [[ -n "$default_val" ]]; then
    read -r -p "$prompt [$default_val]: " val || true
    val=${val:-$default_val}
  else
    read -r -p "$prompt: " val || true
  fi
  printf "%s" "$val"
}

write_env_file() {
  echo "\nConfiguring $ENV_FILE..."
  local DB_NAME DB_USER DB_PASS MARKETSTACK_API_KEYS GIT_REPO GIT_REF
  DB_NAME=$(prompt_var DB_NAME "Postgres DB name" "stocks_db")
  DB_USER=$(prompt_var DB_USER "Postgres DB user" "stock_user")
  DB_PASS=$(prompt_var DB_PASS "Postgres DB password" "stock_pass")
  MARKETSTACK_API_KEYS=$(prompt_var MARKETSTACK_API_KEYS "Marketstack API keys (comma-separated)" "")
  GIT_REPO=$(prompt_var GIT_REPO "App Git repo (URL, used by Dockerfile.git)" "")
  GIT_REF=$(prompt_var GIT_REF "App Git ref (branch/tag/commit)" "main")

  cat > "$ENV_FILE" <<EOF
# Generated by deploy.sh on $(date)
DB_NAME=$DB_NAME
DB_USER=$DB_USER
DB_PASS=$DB_PASS

# Comma-separated API keys for Marketstack
MARKETSTACK_API_KEYS=$MARKETSTACK_API_KEYS

# Repo and ref for the application cloned during image build
GIT_REPO=$GIT_REPO
GIT_REF=$GIT_REF
EOF
  echo "Wrote $ENV_FILE"
}

cmd_clone() {
  local url="${1-}"
  local dir="${2-}"
  local ref="${3-main}"
  if [[ -z "$url" ]]; then
    echo "Repo URL not provided."
    read -r -p "Enter repo URL to clone: " url || true
    if [[ -z "$url" ]]; then
      echo "Error: repo URL required" >&2
      exit 1
    fi
  fi
  if [[ -z "$dir" ]]; then
    dir=$(basename "$url" .git)
  fi
  echo "Cloning $url into $dir ..."
  git clone --depth 1 --branch "$ref" "$url" "$dir"
  echo "Cloned. cd $dir to continue."
}

cmd_init() {
  ensure_compose_file
  if [[ -f "$ENV_FILE" ]]; then
    read -r -p "$ENV_FILE exists. Overwrite? [y/N]: " ans || true
    case "${ans,,}" in
      y|yes) : ;;
      *) echo "Keeping existing $ENV_FILE"; return 0;;
    esac
  fi
  write_env_file
}

cmd_up() {
  ensure_compose_file
  if [[ ! -f "$ENV_FILE" ]]; then
    echo "$ENV_FILE not found. Running init..."
    write_env_file
  fi
  echo "Bringing up stack..."
  docker compose -f "$COMPOSE_FILE" up -d --build
  echo "Services started. Dagster UI: http://localhost:33000  API: http://localhost:8000  Postgres: localhost:65432"
}

cmd_down() {
  ensure_compose_file
  echo "Stopping services..."
  docker compose -f "$COMPOSE_FILE" down
}

cmd_restart() {
  ensure_compose_file
  docker compose -f "$COMPOSE_FILE" down
  docker compose -f "$COMPOSE_FILE" up -d --build
}

cmd_logs() {
  ensure_compose_file
  local svc="${1-}"
  if [[ -n "$svc" ]]; then
    docker compose -f "$COMPOSE_FILE" logs -f --tail=200 "$svc"
  else
    docker compose -f "$COMPOSE_FILE" logs -f --tail=200
  fi
}

cmd_ps() {
  ensure_compose_file
  docker compose -f "$COMPOSE_FILE" ps
}

interactive() {
  echo "Deploy wizard"
  echo "1) Clone repo"
  echo "2) Init (.env.deploy)"
  echo "3) Up"
  echo "4) Down"
  echo "5) Logs"
  echo "6) Status"
  echo "7) Restart"
  echo "0) Exit"
  while true; do
    read -r -p "Select option: " choice || true
    case "$choice" in
      1) read -r -p "Repo URL: " u; read -r -p "Directory (blank=auto): " d; read -r -p "Ref [main]: " r; r=${r:-main}; cmd_clone "$u" "$d" "$r";;
      2) cmd_init ;;
      3) cmd_up ;;
      4) cmd_down ;;
      5) read -r -p "Service (blank=all): " s; cmd_logs "$s" ;;
      6) cmd_ps ;;
      7) cmd_restart ;;
      0) exit 0 ;;
      *) echo "Unknown option" ;;
    esac
  done
}

main() {
  require_compose
  local cmd="${1-}"
  case "$cmd" in
    clone) shift; cmd_clone "$@" ;;
    init) cmd_init ;;
    up) cmd_up ;;
    down) cmd_down ;;
    restart) cmd_restart ;;
    logs) shift || true; cmd_logs "${1-}" ;;
    ps|status) cmd_ps ;;
    "") interactive ;;
    *) echo "Unknown command: $cmd"; echo "See header for usage."; exit 1 ;;
  esac
}

main "$@"
